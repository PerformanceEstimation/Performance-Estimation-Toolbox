clear all; clc;
% In this example, we use a Bregman gradient method for
% solving the constrained smooth strongly convex minimization problem
%   min_x { F(x) = f_1(x) + f_2(x) }
%   for notational convenience we denote xs=argmin_x F(x);
% where f_1(x) is h-smooth and convex and where f_2(x) is a closed convex
% indicator function.
%
% We show how to compute the worst-case value of 
%               min_{1<=i<=N} Dh(x_{i-1},x_i) 
% when xN is obtained by doing N steps of the method starting with
% an initial iterate satisfying Dh(x*,x0)<=1. (Dh is the Bregman distance
% generated by h, between x* and x0)
%
% [1] Heinz H. Bauschke, Jérôme Bolte, and Marc Teboulle. "A Descent Lemma
%     Beyond Lipschitz Gradient Continuity: First-Order Methods Revisited
%     and Applications." (2017)
%
% [2] Radu-Alexandru Dragomir, Adrien B. Taylor, Alexandre d’Aspremont, and
%     Jérôme Bolte. "Optimal Complexity and Certification of Bregman
%     First-Order Methods". (2019)
%
% DISCLAIMER: This example requires some experience with PESTO and PEPs
% (see Section 4 in [2]).

% (0) Initialize an empty PEP
P = pep();

L = 1; % d = Lh - f1 is convex
d  = P.DeclareFunction('Convex');
f1 = P.DeclareFunction('Convex');
h  = (d + f1)/L;
f2 = P.DeclareFunction('ConvexIndicator');

F  = f1 + f2;
% (2) Set up the starting point and initial condition
x0        = P.StartingPoint();        % x0 is some starting point
[ xs, Fs] = F.OptimalPoint('opt');    % xs is an optimal point, and fs=F(xs)
[gfs, fs] = f1.oracle(xs,'opt');
% [gds, ds] = d.oracle(xs);

[gh0, h0] = h.oracle(x0,'x0');
[gf0, f0] = f1.oracle(x0,'x0');
[ghs, hs] = h.oracle(xs,'opt');

P.InitialCondition( hs - h0 - gh0 * (xs - x0) <= 1);    % Initial condition Dh(x*,x0)<=1

% (3) Algorithm
gamma = 1/L;    % stepsize
N     = 10;     % number of iterations

x   = cell(N+1,1);   x{1} = x0;
gfx = cell(N+1,1); gfx{1} = gf0;
fx  = cell(N+1,1);  fx{1} = f0;
ghx = cell(N+1,1); ghx{1} = gh0;
hx  = cell(N+1,1);  hx{1} = h0;
Dhi = cell(N  ,1);
for i = 1:N
    name    = sprintf('x%d',i);
    x{i+1}	= mirror(gfx{i}, ghx{i}, h+f2, gamma, name);
    
    [gfx{i+1}, fx{i+1}] = f1.oracle(name);
    [ghx{i+1}, hx{i+1}] = h.oracle(name);
    Dhi{i} = hx{i}-hx{i+1}-ghx{i+1}*(x{i}-x{i+1});
    P.PerformanceMetric(Dhi{i});
end

% (4) Set up the performance measure

% (5) Solve the PEP
P.solve()

% (6) Evaluate the output
for i = 1:N
    DhValues(i)=double(Dhi{i});
end
[min(DhValues) 2/(N-1)/N]
% Result should match 2/(N-1)/N (see [2])
